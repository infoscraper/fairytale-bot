"""Handlers for story series management"""
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List

from ..keyboards.inline import (
    get_children_keyboard, get_series_keyboard, get_series_actions_keyboard, 
    get_series_episodes_keyboard, get_feedback_keyboard
)
from ..states.series_states import SeriesCreationStates, SeriesManagementStates
from ...services.story_series_service import StorySeriesService
from ...services.child_service import ChildService
from ...models import User, Child, StorySeries
from .history import get_feedback_emoji

router = Router()


@router.message(Command("series"))
async def series_command(
    message: Message,
    session: AsyncSession,
    current_user: User
):
    """Show user's story series"""
    child_service = ChildService(session)
    children = await child_service.get_user_children(current_user.id)
    
    if not children:
        await message.answer(
            "üìö **–°–µ—Ä–∏–π–Ω—ã–µ —Å–∫–∞–∑–∫–∏**\n\n"
            "–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –ø—Ä–æ—Ñ–∏–ª–µ–π –¥–µ—Ç–µ–π.\n"
            "–°–æ–∑–¥–∞–π—Ç–µ –ø–µ—Ä–≤—ã–π –ø—Ä–æ—Ñ–∏–ª—å –∫–æ–º–∞–Ω–¥–æ–π /story! ‚ú®"
        )
        return
    
    if len(children) == 1:
        # Show series for single child
        child = children[0]
        await show_child_series(message, session, current_user, child.id)
    else:
        # Show children selection
        keyboard = get_children_keyboard(children, callback_prefix="child_series")
        await message.answer(
            "üìö **–°–µ—Ä–∏–π–Ω—ã–µ —Å–∫–∞–∑–∫–∏**\n\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–±–µ–Ω–∫–∞ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–µ—Ä–∏—è–º–∏:",
            reply_markup=keyboard,
            parse_mode="Markdown"
        )


async def show_child_series(
    message_or_callback,
    session: AsyncSession,
    current_user: User,
    child_id: int
):
    """Show series for specific child"""
    child_service = ChildService(session)
    series_service = StorySeriesService(session)
    
    child = await child_service.get_child_by_id(child_id)
    if not child or child.user_id != current_user.id:
        if hasattr(message_or_callback, 'answer'):
            await message_or_callback.answer("–†–µ–±–µ–Ω–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return
    
    child_series = await series_service.get_child_series(child_id)
    
    text = f"üìö **–°–µ—Ä–∏–∏ –¥–ª—è {child.name}**\n\n"
    
    if not child_series:
        text += (
            "–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å–µ—Ä–∏–π–Ω—ã—Ö —Å–∫–∞–∑–æ–∫.\n"
            "–°–æ–∑–¥–∞–π—Ç–µ –ø–µ—Ä–≤—É—é —Å–µ—Ä–∏—é –¥–ª—è —É–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω—ã—Ö –ø—Ä–æ–¥–æ–ª–∂–∞—é—â–∏—Ö—Å—è –ø—Ä–∏–∫–ª—é—á–µ–Ω–∏–π! ‚ú®"
        )
    else:
        text += f"–í—Å–µ–≥–æ —Å–µ—Ä–∏–π: {len(child_series)}\n\n"
        for series in child_series[:3]:  # Show first 3
            status = "üìñ –ê–∫—Ç–∏–≤–Ω–∞—è" if series.is_active else "‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–∞" if series.is_completed else "‚è∏Ô∏è –ü—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞"
            last_episode = series.last_episode_date.strftime("%d.%m") if series.last_episode_date else "–Ω–∏–∫–æ–≥–¥–∞"
            text += (
                f"‚Ä¢ **{series.series_name}** ({status})\n"
                f"  üìç {series.setting} ‚Ä¢ {series.total_episodes} —ç–ø. ‚Ä¢ {last_episode}\n\n"
            )
    
    keyboard = get_series_keyboard(child_series, child_id)
    
    if hasattr(message_or_callback, 'edit_text'):
        await message_or_callback.edit_text(text, reply_markup=keyboard, parse_mode="Markdown")
    else:
        await message_or_callback.answer(text, reply_markup=keyboard, parse_mode="Markdown")


@router.callback_query(F.data.startswith("child_series_"))
async def child_series_selection(
    callback: CallbackQuery,
    session: AsyncSession,
    current_user: User
):
    """Handle child selection for series"""
    child_id = int(callback.data.split("_")[2])
    await show_child_series(callback.message, session, current_user, child_id)
    await callback.answer()


@router.callback_query(F.data.startswith("create_series_"))
async def create_series_start(
    callback: CallbackQuery,
    session: AsyncSession,
    current_user: User,
    state: FSMContext
):
    """Start creating new series"""
    child_id = int(callback.data.split("_")[2])
    
    child_service = ChildService(session)
    child = await child_service.get_child_by_id(child_id)
    
    if not child or child.user_id != current_user.id:
        await callback.answer("–†–µ–±–µ–Ω–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return
    
    await state.update_data(child_id=child_id, child_name=child.name)
    await state.set_state(SeriesCreationStates.awaiting_setting)
    
    await callback.message.edit_text(
        f"‚ú® **–°–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Ä–∏–∏ –¥–ª—è {child.name}**\n\n"
        "üåç **–®–∞–≥ 1: –ú–∏—Ä –ø—Ä–∏–∫–ª—é—á–µ–Ω–∏–π**\n\n"
        "–í –∫–∞–∫–æ–º –º–∏—Ä–µ –±—É–¥—É—Ç –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç—å –ø—Ä–∏–∫–ª—é—á–µ–Ω–∏—è?\n"
        "–ü—Ä–∏–º–µ—Ä—ã: –í–æ–ª—à–µ–±–Ω—ã–π –ª–µ—Å, –ü–æ–¥–≤–æ–¥–Ω–æ–µ —Ü–∞—Ä—Å—Ç–≤–æ, –ö–æ—Å–º–∏—á–µ—Å–∫–∞—è —Å—Ç–∞–Ω—Ü–∏—è, –°–∫–∞–∑–æ—á–Ω—ã–π –≥–æ—Ä–æ–¥\n\n"
        "–ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–∏—Ä–∞:"
    )
    await callback.answer()


@router.message(SeriesCreationStates.awaiting_setting)
async def process_series_setting(
    message: Message,
    state: FSMContext
):
    """Process series setting input"""
    setting = message.text.strip()
    
    if len(setting) < 3 or len(setting) > 100:
        await message.answer("–ù–∞–∑–≤–∞–Ω–∏–µ –º–∏—Ä–∞ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 3 –¥–æ 100 —Å–∏–º–≤–æ–ª–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:")
        return
    
    await state.update_data(setting=setting)
    await state.set_state(SeriesCreationStates.awaiting_characters)
    
    await message.answer(
        f"üé≠ **–®–∞–≥ 2: –ü–æ—Å—Ç–æ—è–Ω–Ω—ã–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∏**\n\n"
        f"–ö—Ç–æ –±—É–¥–µ—Ç —Å–æ–ø—Ä–æ–≤–æ–∂–¥–∞—Ç—å –≥–µ—Ä–æ—è –≤ –º–∏—Ä–µ \"{setting}\"?\n"
        "–ù–∞–ø–∏—à–∏—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é.\n\n"
        "–ü—Ä–∏–º–µ—Ä—ã: –º—É–¥—Ä–∞—è —Å–æ–≤–∞, –≤–µ—Å–µ–ª—ã–π –¥—Ä–∞–∫–æ–Ω—á–∏–∫, –≥–æ–≤–æ—Ä—è—â–∏–π –∫–æ—Ç\n\n"
        "–í–≤–µ–¥–∏—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π:"
    )


@router.message(SeriesCreationStates.awaiting_characters)
async def process_series_characters(
    message: Message,
    state: FSMContext
):
    """Process series characters input"""
    characters_text = message.text.strip()
    characters = [char.strip() for char in characters_text.split(',') if char.strip()]
    
    if not characters:
        await message.answer("–î–æ–±–∞–≤—å—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:")
        return
    
    if len(characters) > 5:
        await message.answer("–°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π (–º–∞–∫—Å–∏–º—É–º 5). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:")
        return
    
    await state.update_data(characters=characters)
    await state.set_state(SeriesCreationStates.awaiting_description)
    
    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
    skip_keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å", callback_data="skip_description")]
    ])
    
    await message.answer(
        "üìù **–û–ø–∏—Å–∞–Ω–∏–µ —Å–µ—Ä–∏–∏** (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)\n\n"
        "–ù–∞–ø–∏—à–∏—Ç–µ –∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –≤–∞—à–µ–π —Å–µ—Ä–∏–∏ —Å–∫–∞–∑–æ–∫. "
        "–≠—Ç–æ –ø–æ–º–æ–∂–µ—Ç –º–Ω–µ –ª—É—á—à–µ –ø–æ–Ω—è—Ç—å –æ–±—â—É—é –∏–¥–µ—é, –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–µ —ç—Ç–æ—Ç —à–∞–≥.",
        reply_markup=skip_keyboard,
        parse_mode="Markdown"
    )


@router.callback_query(F.data == "skip_description")
async def skip_series_description(
    callback: CallbackQuery,
    state: FSMContext,
    session: AsyncSession,
    current_user: User
):
    """Skip series description and create series"""
    data = await state.get_data()
    child_id = data["child_id"]
    setting = data["setting"]
    recurring_characters = data.get("recurring_characters", [])

    child_service = ChildService(session)
    child = await child_service.get_child_by_id(child_id)

    if not child:
        await callback.message.edit_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: —Ä–µ–±–µ–Ω–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.", parse_mode="Markdown")
        await state.clear()
        await callback.answer()
        return

    series_service = StorySeriesService(session)
    new_series = await series_service.create_series(
        user_id=current_user.id,
        child_id=child_id,
        child_name=child.name,
        setting=setting,
        recurring_characters=recurring_characters,
        description=None  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ
    )

    await state.clear()
    
    from ..keyboards.inline import get_series_actions_keyboard
    await callback.message.edit_text(
        f"‚úÖ **–°–µ—Ä–∏—è '{new_series.series_name}' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!**\n\n"
        "–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞—Ç—å –ø–µ—Ä–≤—ã–π —ç–ø–∏–∑–æ–¥.",
        reply_markup=get_series_actions_keyboard(new_series.id),
        parse_mode="Markdown"
    )
    await callback.answer()


@router.message(SeriesCreationStates.awaiting_description)
async def process_series_description(
    message: Message,
    state: FSMContext,
    session: AsyncSession,
    current_user: User
):
    """Process series description and create series"""
    description = message.text.strip() if message.text.strip().lower() != "–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å" else None
    
    data = await state.get_data()
    child_id = data["child_id"]
    child_name = data["child_name"]
    setting = data["setting"]
    characters = data["characters"]
    
    try:
        # Create series
        series_service = StorySeriesService(session)
        series = await series_service.create_series(
            user_id=current_user.id,
            child_id=child_id,
            child_name=child_name,
            setting=setting,
            recurring_characters=characters,
            description=description
        )
        
        await state.clear()
        
        # Show created series
        characters_text = ", ".join(characters)
        await message.answer(
            f"üéâ **–°–µ—Ä–∏—è —Å–æ–∑–¥–∞–Ω–∞!**\n\n"
            f"üìö **{series.series_name}**\n"
            f"üåç –ú–∏—Ä: {setting}\n"
            f"üé≠ –ü–µ—Ä—Å–æ–Ω–∞–∂–∏: {characters_text}\n"
            f"üìù –û–ø–∏—Å–∞–Ω–∏–µ: {series.description}\n\n"
            "–¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å –ø–µ—Ä–≤—ã–π —ç–ø–∏–∑–æ–¥!"
        )
        
        # Show series actions
        keyboard = get_series_actions_keyboard(series.id)
        await message.answer(
            f"üìñ **{series.series_name}**\n\n"
            "–ß—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å?",
            reply_markup=keyboard
        )
        
    except Exception as e:
        await message.answer(f"üòî –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ—Ä–∏–∏: {str(e)}")
        await state.clear()


@router.callback_query(F.data.regexp(r"^series_\d+$"))
async def show_series_details(
    callback: CallbackQuery,
    session: AsyncSession,
    current_user: User
):
    """Show series details and actions"""
    series_id = int(callback.data.split("_")[1])
    
    series_service = StorySeriesService(session)
    series = await series_service.get_series_by_id(series_id)
    
    if not series or series.user_id != current_user.id:
        await callback.answer("–°–µ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
        return
    
    status = "üìñ –ê–∫—Ç–∏–≤–Ω–∞—è" if series.is_active else "‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–∞" if series.is_completed else "‚è∏Ô∏è –ü—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞"
    characters_text = ", ".join(series.recurring_characters) if series.recurring_characters else "–Ω–µ—Ç"
    last_episode = series.last_episode_date.strftime("%d.%m.%Y") if series.last_episode_date else "–Ω–∏–∫–æ–≥–¥–∞"
    
    text = (
        f"üìö **{series.series_name}**\n\n"
        f"üé≠ –ì–ª–∞–≤–Ω—ã–π –≥–µ—Ä–æ–π: {series.main_character}\n"
        f"üåç –ú–∏—Ä: {series.setting}\n"
        f"üë• –ü–µ—Ä—Å–æ–Ω–∞–∂–∏: {characters_text}\n"
        f"üìä –°—Ç–∞—Ç—É—Å: {status}\n"
        f"üìñ –≠–ø–∏–∑–æ–¥–æ–≤: {series.total_episodes}\n"
        f"üìÖ –ü–æ—Å–ª–µ–¥–Ω–∏–π —ç–ø–∏–∑–æ–¥: {last_episode}\n\n"
        f"üìù {series.description or '–û–ø–∏—Å–∞–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç'}"
    )
    
    keyboard = get_series_actions_keyboard(series_id)
    await callback.message.edit_text(text, reply_markup=keyboard)
    await callback.answer()


@router.callback_query(F.data.startswith("new_episode_"))
async def create_new_episode(
    callback: CallbackQuery,
    session: AsyncSession,
    current_user: User
):
    """Create new episode in series"""
    series_id = int(callback.data.split("_")[2])
    
    series_service = StorySeriesService(session)
    series = await series_service.get_series_by_id(series_id)
    
    if not series or series.user_id != current_user.id:
        await callback.answer("–°–µ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
        return
    
    if not series.is_active:
        await callback.answer("–°–µ—Ä–∏—è –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞", show_alert=True)
        return
    
    # Show progress
    progress_message = await callback.message.edit_text(
        f"‚ú® –°–æ–∑–¥–∞—é —ç–ø–∏–∑–æ–¥ {series.current_episode + 1} —Å–µ—Ä–∏–∏ '{series.series_name}'...\n"
        f"‚è≥ –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥..."
    )
    
    try:
        # Create episode
        story = await series_service.create_next_episode(series_id)
        
        # Show created episode
        date_str = story.created_at.strftime("%d.%m.%Y –≤ %H:%M")
        
        story_text = (
            f"üìñ **–≠–ø–∏–∑–æ–¥ {story.episode_number}: {story.theme}**\n\n"
            f"üìö –°–µ—Ä–∏—è: {series.series_name}\n"
            f"üìÖ –°–æ–∑–¥–∞–Ω: {date_str}\n"
            f"üí´ –ú–æ—Ä–∞–ª—å: {story.moral}\n\n"
            f"{'='*30}\n\n"
            f"{story.story_text}\n\n"
            f"{'='*30}"
        )
        
        keyboard = get_feedback_keyboard(story.id, story.child_id)
        await progress_message.edit_text(story_text, reply_markup=keyboard, parse_mode="Markdown")
        
    except Exception as e:
        await progress_message.edit_text(
            "üòî –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —ç–ø–∏–∑–æ–¥–∞.\n\n"
            "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É."
        )
    
    await callback.answer()


@router.callback_query(F.data.startswith("custom_episode_"))
async def custom_episode_start(
    callback: CallbackQuery,
    state: FSMContext
):
    """Start custom episode creation"""
    series_id = int(callback.data.split("_")[2])
    
    await state.update_data(series_id=series_id)
    await state.set_state(SeriesManagementStates.awaiting_episode_prompt)
    
    await callback.message.edit_text(
        "‚úèÔ∏è **–≠–ø–∏–∑–æ–¥ —Å –∫–∞—Å—Ç–æ–º–Ω–æ–π —Ç–µ–º–æ–π**\n\n"
        "–û–ø–∏—à–∏—Ç–µ, —á—Ç–æ –¥–æ–ª–∂–Ω–æ –ø—Ä–æ–∏–∑–æ–π—Ç–∏ –≤ —ç—Ç–æ–º —ç–ø–∏–∑–æ–¥–µ:\n"
        "–ü—Ä–∏–º–µ—Ä—ã: '–≤—Å—Ç—Ä–µ—á–∞ —Å –Ω–æ–≤—ã–º –¥—Ä—É–≥–æ–º', '–ø–æ–∏—Å–∫ –ø–æ—Ç–µ—Ä—è–Ω–Ω–æ–≥–æ —Å–æ–∫—Ä–æ–≤–∏—â–∞', '–ø–æ–º–æ—â—å –ª–µ—Å–Ω—ã–º –∂–∏—Ç–µ–ª—è–º'\n\n"
        "–ù–∞–ø–∏—à–∏—Ç–µ —Ç–µ–º—É —ç–ø–∏–∑–æ–¥–∞:"
    )
    await callback.answer()


@router.message(SeriesManagementStates.awaiting_episode_prompt)
async def process_custom_episode(
    message: Message,
    state: FSMContext,
    session: AsyncSession,
    current_user: User
):
    """Process custom episode creation"""
    custom_prompt = message.text.strip()
    
    if len(custom_prompt) < 5:
        await message.answer("–û–ø–∏—à–∏—Ç–µ —Ç–µ–º—É –ø–æ–¥—Ä–æ–±–Ω–µ–µ (–º–∏–Ω–∏–º—É–º 5 —Å–∏–º–≤–æ–ª–æ–≤):")
        return
    
    data = await state.get_data()
    series_id = data["series_id"]
    
    # Show progress
    progress_message = await message.answer(
        f"‚ú® –°–æ–∑–¥–∞—é —ç–ø–∏–∑–æ–¥ –Ω–∞ —Ç–µ–º—É '{custom_prompt}'...\n"
        f"‚è≥ –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥..."
    )
    
    try:
        series_service = StorySeriesService(session)
        story = await series_service.create_next_episode(series_id, custom_prompt)
        
        await state.clear()
        
        # Show created episode
        date_str = story.created_at.strftime("%d.%m.%Y –≤ %H:%M")
        
        story_text = (
            f"üìñ **–≠–ø–∏–∑–æ–¥ {story.episode_number}: {story.theme}**\n\n"
            f"üìÖ –°–æ–∑–¥–∞–Ω: {date_str}\n"
            f"üí´ –ú–æ—Ä–∞–ª—å: {story.moral}\n\n"
            f"{'='*30}\n\n"
            f"{story.story_text}\n\n"
            f"{'='*30}"
        )
        
        keyboard = get_feedback_keyboard(story.id, story.child_id)
        await progress_message.edit_text(story_text, reply_markup=keyboard, parse_mode="Markdown")
        
    except Exception as e:
        await progress_message.edit_text(
            "üòî –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —ç–ø–∏–∑–æ–¥–∞.\n\n"
            "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ —á–µ—Ä–µ–∑ –º–∏–Ω—É—Ç—É."
        )
        await state.clear()


@router.callback_query(F.data.startswith("series_episodes_"))
async def show_series_episodes(
    callback: CallbackQuery,
    session: AsyncSession,
    current_user: User
):
    """Show all episodes in series"""
    series_id = int(callback.data.split("_")[2])
    
    series_service = StorySeriesService(session)
    series = await series_service.get_series_by_id(series_id)
    
    if not series or series.user_id != current_user.id:
        await callback.answer("–°–µ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞", show_alert=True)
        return
    
    episodes = await series_service.get_series_episodes(series_id)
    
    if not episodes:
        await callback.message.edit_text(
            f"üìö **{series.series_name}**\n\n"
            "–í —ç—Ç–æ–π —Å–µ—Ä–∏–∏ –ø–æ–∫–∞ –Ω–µ—Ç —ç–ø–∏–∑–æ–¥–æ–≤.\n"
            "–°–æ–∑–¥–∞–π—Ç–µ –ø–µ—Ä–≤—ã–π —ç–ø–∏–∑–æ–¥!",
            reply_markup=get_series_actions_keyboard(series_id)
        )
        return
    
    text = f"üìö **{series.series_name}** - –í—Å–µ —ç–ø–∏–∑–æ–¥—ã\n\n"
    for episode in episodes:
        date_str = episode.created_at.strftime("%d.%m")
        feedback_emoji = "üíñ" if episode.child_feedback == "loved" else "üëç" if episode.child_feedback == "liked" else "üìñ"
        text += f"{feedback_emoji} –≠–ø–∏–∑–æ–¥ {episode.episode_number}: {episode.theme} ({date_str})\n"
    
    keyboard = get_series_episodes_keyboard(episodes, series_id)
    await callback.message.edit_text(text, reply_markup=keyboard)
    await callback.answer()


@router.callback_query(F.data == "back_to_series")
async def back_to_series(
    callback: CallbackQuery,
    session: AsyncSession,
    current_user: User
):
    """Return to series selection"""
    # Re-run series command logic
    await series_command(callback.message, session, current_user)
    await callback.answer()
